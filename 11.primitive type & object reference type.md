-   원시 타입 : 변경 불가능한 값
    -   원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다.
    -   원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 잔달된다.
        -   값에 의한 전달
-   객체 타입 : 변경 가능한 값
    -   객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.
    -   객체를 가리키는 변수를 다른 변수를 할당하면 원본의 참조 값이 복사되어 전달된다.
        -   참조에 의한 전달

# 원시 값

```
변경 불가능한 값
```

-   한번 생성된 원시 값은 읽기 전용 값으로 변경할 수 없음
    -   변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 혹은 메모리 공간을 식볋기 위해 붙인 이름
    -   값은 변수에 저장된 데이터, 표현식이 생성된 결과
        -   변경 불가능하다는 것은 변수가 아니라 값
            -   원시 값 자체를 변경할 수 없다는 의미
        -   변수는 언제든지 새로운 메모리 공간 확보 후 재할당으로 변수 값 변경 가능
            -   변수의 메모리 주소가 변경됨
        -   상수(const)는 재할당이 금지된 변수
            -   객체는 변경 가능 > 참조 값은 그대로 있기 때문
-   원시 값의 이러한 특성을 불변성이라 함
-   재할당 이외 변수 값을 변경할 수 있는 방법이 없음
    -   예기치 않게 변수가 변경되는 건 값의 변경(상태 변경)을 추적하기 어렵게 만듬

```
let str = ''; // 빈 문자열
let str2 = 'Hello'; // 5개의 문자로 이뤄진 문자열
```

-   원시 값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 결정
-   ECMAScript 사양에 문자열과 숫자 타입 이외의 원시 타입은 크기를 규정하지 않음
    -   문자열의 1개 문자는 2바이트의 메모리 공간에 저장된다(단순하게 계산했을 때)
    -   숫자값은 1도 100000도 동일한 8바이트가 필요
    -   이외는 브라우저 제조사 구현에 따라 다를 수 있음
-   C에서는 문자의 배열로 처리, 자바에서는 문자열을 String 객체로 처리
-   원시 타입 문자열 타입은 자바스크립트의 장점 중 하나.
    -   원시 타입이고, 변경 불가능 하므로

```
let str = 'string';

str[0] = 'S';

console.log(str); // string
```

-   문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있음
    -   유사 배열 객체 : 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체
    -   이터러블 : 순회가능한, 반복가능한 객체
-   하지만 인덱스로 접근해 변경해도 변경되지 않음
    -   문자열은 변경 불가능한 값이기 때문
    -   이때 에러를 발생시키지 않음
    -   데이터의 신뢰성 보장
-   변수에 새로운 문자열을 재할당하는 것은 가능

```
let score = 80;
let copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // 80
```

-   변수에 변수를 할당했을 때
    -   score는 변수 값 80으로 평가되므로 copy 변수에도 80이 할당
    -   이때 새로운 숫자 값 80이 생성되어 copy에 할당
        -   할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달
            -   이를 값에 의한 전달 이라 함
                -   엄격하게 표현하면 값이 전달되는 것이 아닌 메모리 주소가 전달
                -   변수는 메모리 주소를 기억
    -   score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값
        -   재할당을 통해 값을 변경하더라도 서로 간섭할 수 없음
-   자바스크립트 엔진 제조사에 따라 내부 동작 방식에 미묘한 차이가 있을 수 있음

# 객체

-   프로퍼티 개수가 정해져 있지 않음
-   동적으로 추가 되고 삭제할 수 있음
-   프로퍼티 값에 제약이 없음
    -   따라서 원시 값과 같이 확보해야할 메모리 공간의 크기를 사전에 정해둘 수 없다
-   객체 관리 방식이 브라우저 마다 다를 수 있음
-   객체에 따라 크기가 매우 클 수 있음
-   객체를 생성하고 프로퍼티에 접근하는 것도 원시 값과 비교할 때 비용이 많이 드는 일
    -   따라서 객체는 원시 값과 다른 방식으로 동작하도록 설계

![해시테이블](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb1zOw1%2FbtqL6HAW7jy%2FjpBA5pPkQFnfiZcPLakg00%2Fimg.png)

-   자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 `해시 테이블`이라 생각할 수 있음
    -   해시 테이블 : key, value로 데이터를 저장하는 자료구조
        -   배열(버킷)을 사용해 데이터를 저장하고 인덱스를 활용해 값을 저장 검색
-   대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 해시테이블 보다 나은 방법으로 객체를 구현
-   클래스 기반 객체지향 프로그래밍 언어와 다르게 객체 생성 이후에도 동적으로 프로퍼티와 메서드 추가 가능

    -   이는 이론적으로 클래스 기반 객체지향 프로그래밍 언어의 객체보다 생성, 프로퍼티 접근 비용이 더 많이 드는 비효율적인 방식
    -   V8 엔진은 프로퍼티 접근에 `동적 탐색` 대신 `히든 클래스`라는 방식을 사용해 성능 보장
        -   동적 탐색 : 프로퍼티 값을 읽어야 할 때마다 프로퍼티를 찾아내야 하는 탐색
            -   자바스크립트는 `동적 타이핑 언어` 이기 때문
                -   정적 타이핑 언어 : 데이터 타입을 컴파일 시 결정
                -   동적 타이핑 언어 : 코드를 실행할 때 상황에 따라 데이터 타입 결정
                    -   사전에 결정된 값을 가져오는 것 보다 비용이 발생
        -   히든 클래스 : 프로퍼티가 바뀔 때 각각 그 프로퍼티의 오프셋을 업데이트 한 뒤 그 값을 가지고 있는 방식
            -   오프셋 : 기준이 되는 주소에 더해진 값
            -   히든클래스 특징
                -   객체는 반드시 하나의 히든클래스를 참조한다
                -   히든 클래스는 각 프로퍼티에 대해 메모리 오프셋을 가지고 있다
                -   ... 아래 글 참조
        -   [V8의 히든 클래스 이야기](https://engineering.linecorp.com/ko/blog/v8-hidden-class)
        -   [자바스크립트 엔진의 최적화 기법](https://meetup.toast.com/posts/78)

![객체의 할당](https://user-images.githubusercontent.com/80154058/141670958-33f78d5d-e625-4079-8815-cadf3d8c8ac0.png)

-   객체는 변경 가능한 값
    -   메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근하기 때문
        -   재할당 없이 객체를 직접 변경(프로퍼티 추가, 삭제, 갱신)할 수 있음
            -   객체를 변경 할 때마다 원시 값처럼 이전 값을 복사해서 새롭게 생성한다면 비효율적
                -   생성하는 비용이 큼, 메모리의 효율적 소비가 어렵고 성능이 나빠짐
-   이때문에 여러개의 식별자가 하나의 객체를 공유할 수 있는 부작용이 발생

```
// 얕은 복사 (shallow copy)
const o = { x: { y: 1 } };

const c1 = { ...o };
console.log(c1 === o); // false
console.log(c1.x === o.x) // true

// 깊은 복사 (deep copy)
const _ = require('lodash');

const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

-   얕은 복사는 객체를 변경하면 복사된 객체에도 영향을 줌
    -   이를 참조에 의한 전달이라 함
        -   식별자가 동일한 객체(레퍼런스)를 가지는 것
-   깊은 복사는 서로 영향을 주지 않음

    -   원시 값 처럼 완전한 복사본

-   값에 의한 전달, 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장 값을 복사해서 전달
    -   결국 동일하고 자바스크립트에 참조에 의한 전달은 없다고 말할 수 있음
        -   하지만 정확한 용어가 존재하지 않음, 공유에 의한 전달이라 표현하는 경우도 있음
